{"name":"Java-neo4j-client","tagline":"A compact Neo4J Java API for connecting to non embedded instances.","body":"java-neo4j-client\r\n=================\r\n\r\nA compact Neo4J Java API for connecting to non embedded instances.\r\n\r\n[![Build Status](https://travis-ci.org/inner-loop/java-neo4j-client.svg?branch=master)](https://travis-ci.org/inner-loop/java-neo4j-client)\r\n\r\n# Features\r\n\r\n1. No 3rd party dependencies (except [SLF4J](http://www.slf4j.org/)).\r\n1. Very simple, Neo4J specific API that only uses Cypher, the Neo4J query language.\r\n1. Support for Graph and Row based result retrieval.\r\n1. Allows multiple queries per Transaction. Useful for batching or realising patterns like [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html).\r\n1. Built to be used with the [Java Neo4J OGM](https://github.com/inner-loop/java-neo4j-ogm).\r\n1. Can be used as a placeholder API until the official Neo4J Binary Protocol Java driver is released.\r\n\r\n# Usage\r\n\r\n## Install\r\n\r\nThis driver currently requires Java 8+.\r\n\r\nTo install from Maven:\r\n\r\n```maven\r\n<dependency>\r\n    <groupId>io.innerloop</groupId>\r\n    <artifactId>java-neo4j-client</artifactId>\r\n    <version>0.2.0</version>\r\n</dependency>\r\n```\r\n\r\nTo install from Gradle:\r\n\r\n```gradle\r\ncompile group: 'io.innerloop', name: 'java-neo4j-client', version: '0.2.0'\r\n```\r\n\r\n## Initialise\r\n\r\nInitialise the driver like so:\r\n\r\n```java\r\nNeo4jClient client = new Neo4jClient(\"http://localhost:7474/db/data\");\r\n```\r\n\r\nor with credentials:\r\n\r\n```java\r\nNeo4jClient client = new Neo4jClient(\"http://localhost:7474/db/data\", \"username\", \"password\");\r\n```\r\n\r\nYou will only need one of these instances per application. This object is thread safe so feel free to share it.\r\n\r\n## Connections and Statements.\r\n\r\njava-neo4j-driver Connections are a little like JDBC Connections and Transactions merged together.\r\n\r\nAll Neo4J Queries must run within a Neo4J Transaction.  This driver allows batches of statements to be \r\nflushed to the database intermittently before being committed. It also provides the capability to rollback Transactions\r\non a connection.\r\n\r\nStatements also come in two flavours:\r\n\r\n1. _Graph Statements_: Will return results in a graph format. Useful when you want to visualise your graph or map it to\r\ndomain objects etc. It is important to remember that when performing Graph queries you will need to return relationships, not just the nodes!  \r\nFor example: ```MATCH (n:Node)-[r]-() RETURN n, COLLECT(r) AS r```\r\n1. _Row based Statements_: Will return results in a more JDBC familiar table format, with column names and rows of data.\r\nUseful if you want to get aggregate results or perform more relational type queries. This mode is useful when you want\r\nto extract tabular data from your Neo4J server. This method will return items back as RowSets. RowSets are just stripped\r\n down versions of the JDBC ResultSet. You can iterate through RowSets using the next() method.\r\n\r\nStatements also support parameter replacement. Simply use a placeholder in your cypher query like so: ```{ placeholder }```. See \r\nexamples for more details.\r\n\r\n\r\n## Examples\r\n\r\n### Basic Example.\r\n\r\nThis example will use two existing items (A User and a Tweet) and connect them together. It will then\r\nretrieve all tweets tweeted by a user then flush them to the database, thus allowing us to see the results of \r\nthe call.\r\n\r\nWe then do an update the user object itself before committing the result and getting the neo4j id of the user.\r\n\r\nIt is worth noticing that when ```flush()``` is called, the transaction is still alive. It's important to not too\r\ntoo much data manipulation inside of the transactions otherwise it could time out.  If you anticipate a very long\r\nrunning transaction you may call the Connection.resetExpiry() method.\r\n\r\n```java\r\nNeo4jClient client = new Neo4jClient(\"http://localhost:7474/db/data\");\r\n\r\nConnection connection = client.getConnection(); // gets the active connection on this Thread.\r\n\r\nRowStatement statement1 = new RowStatement(\"MATCH (a:User{id:{0}}), (b:Tweet{id:{1}}) MERGE (a)-[:TWEETED]-(b)\");\r\nstatement1.setParam(\"0\", \"a1b2c3d4\");\r\nstatement1.setParam(\"1\", \"e5f6g7h8\");\r\nconnection.add(statement1);\r\n\r\nGraphStatement statement2 = new GraphStatement(\"MATCH (a:User{id:{userId}})-[r:TWEETED]-() RETURN a, COLLECT(r) AS r\");\r\nstatement2.setParam(\"userId\", \"a1b2c3d4\");\r\nconnection.add(statement2);\r\n\r\n// this will execute any statements that have already appeared. Writes are isolated \r\n// to this Transaction as \"Read Committed\" Isolation.\r\nconnection.flush(); \r\n\r\nGraph userTweets = statement2.getResult();\r\n\r\n// Do something with the user tweets..\r\n// Set<Node> nodes = userTweets.getNodes();\r\n// Set<Relationship> relationships = userTweets.getRelationships();\r\n\r\n\r\nRowStatement statement3 = new RowStatement(\"MATCH (a:User{id:{userId}}) SET a = {user} RETURN id(a)\");\r\nstatement3.setParam(\"userId\", \"a1b2c3d4\");\r\nMap<String, Object> userProperties = new HashMap<>();\r\nuserProperties.put(\"id\", \"a1b2c3d4\");\r\nuserProperties.put(\"email\", \"hello@kitty.com\");\r\nuserProperties.put(\"name\", \"Hello Kitty\");\r\nstatement3.setParam(\"user\", new JSONObject(userProperties));\r\nconnection.add(statement3);\r\n\r\n// Finally commit the whole thing to the database. and check out the user id.\r\nconnection.commit();\r\n\r\nlong userNeo4jId = statement3.getResult().getLong(0);\r\n```\r\n\r\n# Why another Driver?\r\n\r\nThere are a few Java Neo4J Drivers out there, the two most used being the neo4j-rest-binding, a relic from the Neo4J 1.x\r\ndays and the much newer neo4j-jdbc-driver. Neo4j are also working on a binary protocol with a corresponding Java driver.\r\nThis project is meant to be the bridge between that newer driver and what is already available. I hope it's API and\r\ncall semantics are similar to what the binary/native Java driver API and call semantics will look like.\r\n\r\nAs much as the jdbc driver is a big move forward, it suffers from some major issues:\r\n\r\n1. It shoehorns the power of Neo4J's unique graph ability into a relational databases model which just doesn't fit that\r\nnicely with the Graph world.\r\n1. The Neo4J jdbc driver does also not support Neo4J's \"graph\" mode. Graph mode massively reduces the response payload and\r\nit allows users to store and retrieve object graphs, natively. This is so amazing but cannot be done with the JDBC driver AT ALL.\r\n1. It's not lightweight. Users get to add a tonne of dependencies that may conflict with their own dependencies.\r\n\r\nI wanted something that allows me to query Neo4J in the form that makes it so powerful: the graph; but still have the ability\r\nto fall back on row querying when i needed it. Think of this driver as the Java equivalent of of the Neo4j Web Browser.\r\n\r\nThe API deliberately steers clear of JDBC conventions as Neo4J's usage is different enough that trying to make it play\r\nwith that style is more work than it's worth.\r\n\r\nThis driver is specifically intended to work with the [Java Neo4J OGM](https://github.com/inner-loop/java-neo4j-ogm).\r\n\r\n\r\n# Roadmap\r\n\r\n##0.3.x\r\n- Add performance tests.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}